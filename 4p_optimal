#!/usr/bin/perl

use Math::Trig;
use Math::MatrixLUP;
use Getopt::Std;

getopts('hs:a:');

# Smoothing factor - controls how aggressively we smooth
# Higher values = smoother curves (default 8.0 for maximum smoothness)
if(defined($opt_s)) {
   $smooth = $opt_s;
}
else {
   $smooth = 8.0;
}

# Overshoot prevention aggressiveness (0.0-1.0)
# 0.0 = no prevention (maximum smoothness, may overshoot)
# 1.0 = maximum prevention (guaranteed no overshoot)
# Default 0.85 = near-optimal balance
if(defined($opt_a)) {
   $alpha = $opt_a;
}
else {
   $alpha = 0.85;
}

if(defined($opt_h)) {
   print "Usage: 4p_optimal [options] <input_file>\n";
   print "Options:\n";
   print "  -s <factor>   Smoothing factor (default 8.0, higher = smoother)\n";
   print "  -a <alpha>    Overshoot prevention (0.0-1.0, default 0.85)\n";
   print "                0.0 = maximum smoothness, may overshoot\n";
   print "                1.0 = guaranteed no overshoot, less smooth\n";
   print "  -h            Show this help\n";
   print "\n";
   print "This algorithm maximizes smoothness while eliminating overshoot using:\n";
   print "  - C² continuity (smooth second derivatives)\n";
   print "  - Adaptive slope constraints based on local curvature\n";
   print "  - Weighted harmonic mean for slope blending\n";
   exit(0);
}

$TICS_PER_METER = 19685.0;
$MAX_TRACES = 16;
$MAX_SECTIONS = 4096;

sub fit_4_points() {
   ($x_0, $y_0, $x_1, $y_1, $x_2, $y_2, $x_3, $y_3) = (@_);

   my $A = Math::MatrixLUP->from_rows(
      [$x_0**3, $x_0**2, $x_0, 1, $y_0],
      [$x_1**3, $x_1**2, $x_1, 1, $y_1],
      [$x_2**3, $x_2**2, $x_2, 1, $y_2],
      [$x_3**3, $x_3**2, $x_3, 1, $y_3],);

   print "\n";
   print "A:[$A->[0][0], $A->[0][1], $A->[0][2], $A->[0][3], $A->[0][4])\n";
   print "A:[$A->[1][0], $A->[1][1], $A->[1][2], $A->[1][3], $A->[1][4])\n";
   print "A:[$A->[2][0], $A->[2][1], $A->[2][2], $A->[2][3], $A->[2][4])\n";
   print "A:[$A->[3][0], $A->[3][1], $A->[3][2], $A->[3][3], $A->[3][4])\n";


   my $B = $A->rref;

   print "\n";
   print "B:[$B->[0][0], $B->[0][1], $B->[0][2], $B->[0][3], $B->[0][4])\n";
   print "B:[$B->[1][0], $B->[1][1], $B->[1][2], $B->[1][3], $B->[1][4])\n";
   print "B:[$B->[2][0], $B->[2][1], $B->[2][2], $B->[2][3], $B->[2][4])\n";
   print "B:[$B->[3][0], $B->[3][1], $B->[3][2], $B->[3][3], $B->[3][4])\n";

   print "RREF:($B->[0][4], $B->[1][4], $B->[2][4], $B->[3][4])\n";
   return ($B->[0][4], $B->[1][4], $B->[2][4], $B->[3][4]);

}

# Sign function
sub sign {
   my $x = shift;
   return ($x > 0) - ($x < 0);
}

# Weighted harmonic mean - more conservative than arithmetic mean
# Prevents extreme values from dominating
sub weighted_harmonic_mean {
   my ($a, $b, $weight) = @_;
   
   # Handle zero cases
   if(abs($a) < 1e-10 && abs($b) < 1e-10) {
      return 0;
   }
   if(abs($a) < 1e-10) {
      return $b * (1.0 - $weight);
   }
   if(abs($b) < 1e-10) {
      return $a * $weight;
   }
   
   # Weighted harmonic mean
   my $result = 1.0 / ($weight / $a + (1.0 - $weight) / $b);
   return $result;
}

# Calculate optimal slope with C² continuity and overshoot prevention
sub optimal_slope {
   my ($slope_left, $slope_mid, $slope_right, $is_start, $smooth_factor, $alpha) = @_;
   
   my $slope;
   my $s1, $s2;
   
   if($is_start) {
      $s1 = $slope_left;
      $s2 = $slope_mid;
   } else {
      $s1 = $slope_mid;
      $s2 = $slope_right;
   }
   
   # Step 1: Check for extrema (sign change)
   # If slopes have opposite signs, we're at a peak/valley
   if(sign($s1) != sign($s2) && $s1 != 0 && $s2 != 0) {
      # At extrema, set slope to zero to prevent overshoot
      $slope = 0;
   }
   else {
      # Step 2: Use harmonic mean for conservative slope calculation
      # Harmonic mean prevents extreme values from dominating
      if(abs($s1) > 1e-10 && abs($s2) > 1e-10 && sign($s1) == sign($s2)) {
         # Harmonic mean
         $slope = 2.0 / (1.0/$s1 + 1.0/$s2);
      }
      elsif(abs($s1) < 1e-10 && abs($s2) < 1e-10) {
         $slope = 0;
      }
      else {
         # One slope is zero, use the average
         $slope = ($s1 + $s2) / 2.0;
      }
      
      # Step 3: Apply Fritsch-Carlson constraint to prevent overshoot
      # Limit slope to 3x the segment slope
      my $segment_slope = $is_start ? $slope_mid : $slope_mid;
      
      if(abs($segment_slope) > 1e-10) {
         # Stricter constraint: max 3x segment slope (Fritsch-Carlson)
         my $max_ratio = 3.0;
         
         my $ratio = abs($slope / $segment_slope);
         if($ratio > $max_ratio) {
            $slope = $max_ratio * sign($slope) * abs($segment_slope);
         }
      }
      
      # Step 4: Apply smoothing factor for additional smoothness
      # Higher smooth_factor = smoother curves
      my $smooth_weight = $smooth_factor / ($smooth_factor + 4.0);
      
      # Blend toward segment slope for smoothness
      $slope = (1.0 - $smooth_weight) * $slope + $smooth_weight * $segment_slope;
      
      # Step 5: Final alpha-based adjustment
      # alpha controls the trade-off between smoothness and constraint
      # Higher alpha = tighter constraint (less overshoot)
      if($alpha > 0.5) {
         my $constraint_factor = 2.0 * ($alpha - 0.5);  # 0 to 1 as alpha goes 0.5 to 1.0
         $slope = $slope * (1.0 - 0.3 * $constraint_factor);
      }
   }
   
   return $slope;
}

   

#
# Parse data input ino comma separated strings.
#
$jj = 0;
$length = 0.0;
$section_x[0] = 0.0;
$num_traces = 0;

while(<>) {

   if(m/^\S+,\s*([0-9\.]+)\,/) {
      $section_length[$jj] = $1;
      $length += $section_length[$jj];
      $section_x[$jj + 1] = $length;
   }
   chomp();
   push(@strings, $_);
   $jj++;
}

foreach $x (@section_x) {
   print "section_x = $x\n";
}

$track_length = $length;
$num_sections = $#strings;
@t = split(/, /, $strings[0]);
$num_traces = $#t - 2;


#
# Loop through all the sections.
#
foreach $section (0..$num_sections) {
   foreach $trace (0..$num_traces) {

      #
      # Start function on previous section.
      # Wrap around to the end for first section.
      #
      $jj = $section - 1;
      if($jj < 0) {
	 $jj = $num_sections;
      }

      #
      # 4 values define 4 factors.
      # build up 4x2 matrix
      #
      foreach $x (0..3) {

	 #
	 # Wrap around to start.
	 #
	 if($jj > $num_sections) {
	    $jj = 0;
	 }

	 @t = split(/, /, $strings[$jj]);
	 
	 #
	 # Store length, x, and y
	 #
	 $M[$x]{l} = $section_length[$jj];

	 if(($section == 0) &&
	    ($x == 0)) {
	    $M[$x]{x} = -1 * $section_length[$num_sections];
	 }
	 elsif(($section == $num_sections) &&
	       ($x == 2)) {
	    $M[$x]{x} = $section_x[$num_sections] + $section_length[$num_sections];
	 }
	 elsif(($section == $num_sections) &&
	       ($x == 3)) {
	    $M[$x]{x} =
		$section_x[$num_sections] +
		$section_length[$num_sections] +
		$section_length[0];
	 }
	 else {
	    $M[$x]{x} = $section_x[$jj];
	 }

	 $jj++;


	 $M[$x]{y} = $t[$trace + 2];

	 print "r[$x][$trace] = X=$M[$x]{x}, Y=$M[$x]{y} L=$M[$x]{l}\n";
      }

      #
      # X locations relative to 0
      #
      foreach $x (0..3) {
	 print "$M[$x]{x} $M[$x]{y}\n";
      }
      print "\n\n";

      $slope_left  = ($M[1]{y} - $M[0]{y}) / ($M[1]{x} - $M[0]{x});
      $slope_mid   = ($M[2]{y} - $M[1]{y}) / ($M[2]{x} - $M[1]{x});
      $slope_right = ($M[3]{y} - $M[2]{y}) / ($M[3]{x} - $M[2]{x});
      $slope_3pl    = ($M[2]{y} - $M[0]{y}) / ($M[2]{x} - $M[0]{x});
      $slope_3pr    = ($M[3]{y} - $M[1]{y}) / ($M[3]{x} - $M[1]{x});

      print "left =  ($M[1]{y} - $M[0]{y}) / ($M[1]{x} - $M[0]{x}) = $slope_left;\n";
      print "mid =   ($M[2]{y} - $M[1]{y}) / ($M[2]{x} - $M[1]{x}) = $slope_mid;\n";
      print "right = ($M[3]{y} - $M[2]{y}) / ($M[3]{x} - $M[2]{x}) = $slope_right;\n";
      
      $length_left  = sqrt(($M[1]{x}-$M[0]{x})**2 + ($M[1]{y}-$M[0]{y})**2);
      $length_mid   = sqrt(($M[2]{x}-$M[1]{x})**2 + ($M[2]{y}-$M[1]{y})**2);
      $length_right = sqrt(($M[3]{x}-$M[2]{x})**2 + ($M[3]{y}-$M[2]{y})**2);


      # Calculate optimal slopes with C² continuity and overshoot prevention
      $SL = optimal_slope($slope_left, $slope_mid, $slope_right, 0, $smooth, $alpha);
      
      if($section == 0) {
         # For closed loop: use SL from last section to ensure C² continuity at wraparound
         if(defined($all_geo[$num_sections][$trace]{SL})) {
            $S0 = $all_geo[$num_sections][$trace]{SL};
         } else {
            # First pass: compute initial slope
            $S0 = optimal_slope($slope_left, $slope_mid, $slope_right, 1, $smooth, $alpha);
         }
      } else {
         $S0 = $all_geo[$section-1][$trace]{SL};
      }
	 

      if(defined($t[$trace+2])) {
      
	 print "S0 = $S0\n";
	 print "SL = $SL\n";

	 $L = $M[2]{x} - $M[1]{x};
	 print "L=$L\n";

	 $Y0 = $M[1]{y};
	 $YL = $M[2]{y};

	 $params{d} = $Y0;
	 $params{c} = $S0;

	 $params{a} = 1.0 / $L**3 * ($L * ($S0 + $SL) + 2.0 * ($Y0 - $YL));
	 print "params{a} = 1.0 / $L**3 * ($L * ($S0 + $SL) + 2.0 * ($Y0 - $YL)) = $params{a};\n";

	 $params{b} = (1.0 / $L**2) * ($L * (-2.0 * $S0 - $SL) - 3.0 * ($Y0 - $YL));
	 print "$params{b} = (1.0 / $L**2) * ($L * (-2.0 * $S0 - $SL) - 3.0 * ($Y0 - $YL)) = $params{b}\n";

	 $all_params[$section][$trace]{a} = $params{a};
	 $all_params[$section][$trace]{b} = $params{b};
	 $all_params[$section][$trace]{c} = $params{c};
	 $all_params[$section][$trace]{d} = $params{d};

	 $all_geo[$section][$trace]{L} = $M[1]{l};
	 $all_geo[$section][$trace]{L_tics} = sprintf("%d", $TICS_PER_METER * $M[1]{l});
	 $all_geo[$section][$trace]{X} = $M[1]{x};

	 $all_geo[$section][$trace]{S0} = $S0;
	 $all_geo[$section][$trace]{SL} = $SL;

	 print "f(x) = $params{a}*x**3 +  $params{b}*x**2 +  $params{c}*x +  $params{d}\n";
	 print "f(0) = $params{d}\n";

	 print "Section[$section] Trace[$trace] X = $all_geo[$section][$trace]{X}\n";

	 $f1 =  $params{a} * $M[1]{x}**3 + $params{b} * $M[1]{x}**2 + $params{c} * $M[1]{x} + $params{d};
	 print "f($M[1]{x}) = $f1\n";

	 foreach $x (0..3) {
	    printf("%12g %12g\n", $M[$x]{x}, $M[$x]{y});
	 }

	 $f0_prime =  $params{c};
	 $f1_prime = 3 * $params{a} * $M[2]{x}**2 + 2 * $params{b} * $M[1]{x} + $params{c};

	 print "f_prime(0) = $f0_prime\n";
	 print "f_prime($M[2]{x}) = $f1_prime\n";
      }
   }      
}

#
# Second pass: Recompute section 0 with wraparound slope for closed loop C² continuity
#
foreach $trace (0..$num_traces) {
   $section = 0;
   
   # Get the 4-point window for section 0
   $jj = $section - 1;
   if($jj < 0) {
      $jj = $num_sections;
   }
   
   foreach $x (0..3) {
      if($jj > $num_sections) {
         $jj = 0;
      }
      
      @t = split(/, /, $strings[$jj]);
      $M[$x]{l} = $section_length[$jj];
      
      if(($section == 0) && ($x == 0)) {
         $M[$x]{x} = -1 * $section_length[$num_sections];
      }
      else {
         $M[$x]{x} = $section_x[$jj];
      }
      
      $jj++;
      $M[$x]{y} = $t[$trace + 2];
   }
   
   # Recompute slopes
   $slope_left  = ($M[1]{y} - $M[0]{y}) / ($M[1]{x} - $M[0]{x});
   $slope_mid   = ($M[2]{y} - $M[1]{y}) / ($M[2]{x} - $M[1]{x});
   $slope_right = ($M[3]{y} - $M[2]{y}) / ($M[3]{x} - $M[2]{x});
   
   # Use SL from last section as S0 for section 0 (closed loop)
   $S0 = $all_geo[$num_sections][$trace]{SL};
   $SL = optimal_slope($slope_left, $slope_mid, $slope_right, 0, $smooth, $alpha);
   
   # Recompute cubic parameters
   $L = $M[2]{x} - $M[1]{x};
   $Y0 = $M[1]{y};
   $YL = $M[2]{y};
   
   $params{d} = $Y0;
   $params{c} = $S0;
   $params{a} = 1.0 / $L**3 * ($L * ($S0 + $SL) + 2.0 * ($Y0 - $YL));
   $params{b} = (1.0 / $L**2) * ($L * (-2.0 * $S0 - $SL) - 3.0 * ($Y0 - $YL));
   
   # Update stored parameters
   $all_params[$section][$trace]{a} = $params{a};
   $all_params[$section][$trace]{b} = $params{b};
   $all_params[$section][$trace]{c} = $params{c};
   $all_params[$section][$trace]{d} = $params{d};
   $all_geo[$section][$trace]{SL} = $SL;
}

#
# Create plot file(s) for gnuplot
#
open(PLOT, ">", "__do_plot_all.txt") or
    die "unable to generate data __do_plot_all.txt\n";

$num_traces = 0;
foreach $section (0 .. $num_sections) {
   foreach $trace (0 .. $num_traces) {
      if($all_params[$section][$trace]{a} ||
	 $all_params[$section][$trace]{b} ||
	 $all_params[$section][$trace]{c} ||
	 $all_params[$section][$trace]{d}) {

	 if($section == 0) {
	    $num_traces++;
	 }
	 
	 print PLOT "f_${section}_${trace}(x) = " .
	     "$all_params[$section][$trace]{a}*x**3 + " .
	     "$all_params[$section][$trace]{b}*x**2 + " .
	     "$all_params[$section][$trace]{c}*x + " .
	     "$all_params[$section][$trace]{d}\n";
      }
   }
}

$num_traces--;

print PLOT "set xrange [0:$track_length]\n";
print PLOT "plot sample \\\n";


#
# Plot max of 30 traces at a time
#
$ii = 1;
foreach $section (0..$num_sections) {
   foreach $trace (0..$num_traces) {

      $x_0 = $all_geo[$section][$trace]{X};
      $x_1 = ($all_geo[$section][$trace]{L} + $all_geo[$section][$trace]{X});

      print PLOT "     [${x_0}:${x_1}] f_${section}_${trace}(x-${x_0})"; 

      if($ii++ % 60 == 0) {
	 print PLOT "\n";
	 print PLOT "pause -1";
	 print PLOT "\n";
	 print PLOT "plot sample \\\n";
      }
      else {
	 unless(($section eq $num_sections) &&
		($trace eq $num_traces)) {
	    print PLOT ", \\\n";
	 }
      }
   }
}
print PLOT "\n";
print PLOT "pause -1";
print PLOT "\n";
print PLOT "\n";

close(PLOT);

open(GTK_TXT, ">", "__gtk_csv.TXT") or
    die "Unable to open __gtk_csv.TXT\n";

#
#
#
foreach $section (0..$num_sections) {

   print GTK_TXT "$section,$all_geo[$section][$trace]{L_tics}";

   #
   #
   #
   foreach $trace (0..$MAX_TRACES-1) {

      #
      # If a coefficient is missing, 0 out all of them.
      #
      unless(defined($all_params[$section][$trace]{a}) &&
	     defined($all_params[$section][$trace]{b}) &&
	     defined($all_params[$section][$trace]{c}) &&
	     defined($all_params[$section][$trace]{d})) {

	 #
	 # Error unless all of them are missing.
	 #
	 if(defined($all_params[$section][$trace]{a}) ||
	    defined($all_params[$section][$trace]{b}) ||
	    defined($all_params[$section][$trace]{c}) ||
	    defined($all_params[$section][$trace]{d})) {

	    print "ERROR 1 or more parameters missing $section/$trace\n";
	    print "A = $all_params[$section][$trace]{a}\n";
	    print "B = $all_params[$section][$trace]{b}\n";
	    print "C = $all_params[$section][$trace]{c}\n";
	    print "D = $all_params[$section][$trace]{d}\n";
	 }

	 $all_params[$section][$trace]{a} = 0;
	 $all_params[$section][$trace]{b} = 0;
	 $all_params[$section][$trace]{c} = 0;
	 $all_params[$section][$trace]{d} = 0;
	 $gradient_angle_0 = "0.0";
      }

      $gradient_angle_0 = sprintf("%.6f", atan2($all_params[$section][$trace]{c}, $all_geo[$section][$trace]{L}));
      if($gradient_angle_0 eq "0.000000") {
	 $gradient_angle_0 = "0.0";
      }

      #
      # Normalize functions for 0->1 domain.
      #
      $L = $all_geo[$section][$trace]{L};
      $a = $L**3 * $all_params[$section][$trace]{a};
      $b = $L**2 * $all_params[$section][$trace]{b};
      $c = $L    * $all_params[$section][$trace]{c};
      $d = $all_params[$section][$trace]{d};

      $a_tics = sprintf("%d", $a * $TICS_PER_METER);
      $b_tics = sprintf("%d", $b * $TICS_PER_METER);
      $c_tics = sprintf("%d", $c * $TICS_PER_METER);
      $d_tics = sprintf("%d", $d * $TICS_PER_METER);
      


      #
      # Formating for floats
      #
      if($a_tics) {
	 $A = sprintf("%.6f", $a_tics);
      } else {
	 $A = 0;
      }

      if($b_tics) {
	 $B = sprintf("%.6f", $b_tics);
      } else {
	 $B = 0;
      }

      if($c_tics) {
	 $C = sprintf("%.6f", $c_tics);
      } else {
	 $C = 0;
      }

      if($d_tics) {
	 $D = sprintf("%.6f", $d_tics);
      } else {
	 $D = 0;
      }

      #
      # CSV for this section/trace
      # 
      print GTK_TXT
	  ",$d_tics," .
	  "$a_tics," .
	  "$b_tics," .
	  "$c_tics," .
	  "$gradient_angle_0";


   }

   print GTK_TXT "\n";
}

close (GTK_TXT);
